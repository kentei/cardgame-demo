/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/server/commonRequire.js":
/*!*************************************!*\
  !*** ./src/server/commonRequire.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.express = __webpack_require__(/*! express */ \"express\");\nmodule.exports.app = __webpack_require__(/*! express */ \"express\")();\nmodule.exports.http = __webpack_require__(/*! http */ \"http\").Server(module.exports.app);\nmodule.exports.io = __webpack_require__(/*! socket.io */ \"socket.io\")(module.exports.http);\n//const io = module.exports.io;\n\n\n//# sourceURL=webpack:///./src/server/commonRequire.js?");

/***/ }),

/***/ "./src/server/commonUtil.js":
/*!**********************************!*\
  !*** ./src/server/commonUtil.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.TRUMPDATA = {\n  total: 54,\n  card: [\n    { type: \"club\", count: 13 },\n    { type: \"spade\", count: 13 },\n    { type: \"heart\", count: 13 },\n    { type: \"diamond\", count: 13 }\n  ],\n  joker: 2\n};\n\nmodule.exports.DEBUG_TRUMPDATA = {\n  total: 15,\n  card: [\n    { type: \"club\", count: 13 },\n    { type: \"spade\", count: 0 },\n    { type: \"heart\", count: 0 },\n    { type: \"diamond\", count: 0 }\n  ],\n  joker: 2\n};\n\nmodule.exports.createUniqueId = function(digits) {\n  var strong = typeof digits !== \"undefined\" ? digits : 1000;\n  return (\n    Date.now().toString(16) + Math.floor(strong * Math.random()).toString(16)\n  );\n};\n\nmodule.exports.sortArrayRandomly = (arrayData) => {\n  var arr = arrayData.concat();\n  var arrLength = arr.length;\n  var randomArr = [];\n  for (var i = 0; i < arrLength; i++) {\n    var randomTarget = Math.floor(Math.random() * arr.length);\n    randomArr[i] = arr[randomTarget];\n    arr.splice(randomTarget, 1);\n  }\n  return randomArr;\n}\n\nmodule.exports.formatDate = (date, format) => {\n  format = format.replace(/yyyy/g, date.getFullYear());\n  format = format.replace(/MM/g, ('0' + (date.getMonth() + 1)).slice(-2));\n  format = format.replace(/dd/g, ('0' + date.getDate()).slice(-2));\n  format = format.replace(/HH/g, ('0' + date.getHours()).slice(-2));\n  format = format.replace(/mm/g, ('0' + date.getMinutes()).slice(-2));\n  format = format.replace(/ss/g, ('0' + date.getSeconds()).slice(-2));\n  format = format.replace(/SSS/g, ('00' + date.getMilliseconds()).slice(-3));\n  return format;\n};\n\nmodule.exports.htmlentities = (str) => {\n    return String(str).replace(/&/g, \"&amp;\")\n              .replace(/\"/g, \"&quot;\")\n              .replace(/</g, \"&lt;\")\n              .replace(/>/g, \"&gt;\");\n}\n\nmodule.exports.sortArray = (targetArr, isASC = true) => {\n  return targetArr.sort((a,b)=>{\n    if(isASC){\n      //番号の昇順\n      if (a.number < b.number) return -1;\n      if (a.number > b.number) return 1;\n      return 0;\n    }else{\n      //番号の降順\n      if (a.number > b.number) return -1;\n      if (a.number < b.number) return 1;\n      return 0;\n    }\n  });\n}\n\n//# sourceURL=webpack:///./src/server/commonUtil.js?");

/***/ }),

/***/ "./src/server/gameUtil.js":
/*!********************************!*\
  !*** ./src/server/gameUtil.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst commonRequire = __webpack_require__(/*! ./commonRequire.js */ \"./src/server/commonRequire.js\");\nconst commonUtil = __webpack_require__(/*! ./commonUtil.js */ \"./src/server/commonUtil.js\");\nconst storeData = __webpack_require__(/*! ./storeData.js */ \"./src/server/storeData.js\");\nconst notifyUtil = __webpack_require__(/*! ./notifyUtil.js */ \"./src/server/notifyUtil.js\");\nconst io = commonRequire.io;\n//const index = require(\"./index.js\");\nconst loggerUtil = __webpack_require__(/*! ./loggerUtil.js */ \"./src/server/loggerUtil.js\");\nconst LOGGER = loggerUtil.logger;\nconst debug = process.env.DEBUG === \"true\" ? true : false;\nconst TRUMP_TEMP = debug ? commonUtil.DEBUG_TRUMPDATA : commonUtil.TRUMPDATA;\n\n\n// const io = index.io;\n\nmodule.exports.gameInit = (count, sockets, roomId) => {\n  storeData.persistentData[roomId][\"fieldCards\"] = [];\n\n  storeData.persistentData[roomId].finishNum = 0;\n  storeData.persistentData[roomId].scoreTable = storeData.createRankTable(count);\n  storeData.persistentData[roomId].elevenback = false;\n  storeData.persistentData[roomId].shibari = false;\n  storeData.persistentData[roomId].revolution = false;\n  storeData.persistentData[roomId].stair = false;\n  storeData.persistentData[roomId][\"order\"] = [];\n  storeData.persistentData[roomId].startedGame = true;\n  storeData.persistentData[roomId].status = \"inProgress\";\n  storeData.persistentData[roomId].rankCount = 1;\n  //もらったカード、あげたカードをクリアする\n  Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(key => {\n    storeData.persistentData[roomId][\"users\"][key].getCard = [];\n    storeData.persistentData[roomId][\"users\"][key].giveCard = [];\n  });\n  \n\n  //まずは順番決め\n  decideOrder(roomId);\n\n  //カード配布\n  handOutCards(count, roomId);\n\n  //準備完了通知\n  if (storeData.persistentData[roomId].gameNum == 1) {\n    //1回目のゲームの場合は完了通知を送る。\n    notifyUtil.notifyGameReady(roomId);\n  } else {\n    //2回目以降はまず献上が先に実施される。(Orderが降順になっているので、それを利用する)\n    if (Object.keys(storeData.persistentData[roomId][\"users\"]).length >= 3) {\n      //3人以上の時\n      notifyUtil.notifyGiveCard(roomId, Object.keys(storeData.persistentData[roomId][\"users\"]).length);\n    } else {\n      //2人の時などは献上はなし\n      notifyUtil.notifyGameReady(roomId);\n    }\n  }\n}\n\nmodule.exports.checkOut = (sc, roomId, userId, currentTurn) => {\n  \n  //if (users[socket.id].card.length <= 0) {\n      //成績をチェックする。\n      checkRank(sc, roomId, userId);\n      commonRequire.io.to(userId).emit(\"finish\", {\n        rankReason: storeData.persistentData[roomId][\"users\"][userId].rankReason\n      });\n      //みんなに知らせる\n      commonRequire.io.to(roomId).emit(\"finishNotification\", {\n        playerName: storeData.persistentData[roomId][\"users\"][userId].dispName,\n        rankReason: storeData.persistentData[roomId][\"users\"][userId].rankReason\n      });\n      LOGGER.debug(\"都落ち判定前：\" + JSON.stringify(storeData.persistentData[roomId][\"users\"]));\n      if (\n        storeData.persistentData[roomId].gameNum != 1 &&\n        Object.keys(storeData.persistentData[roomId][\"users\"]).length >= 4 &&\n        !storeData.persistentData[roomId][\"users\"][userId].firstPlace &&\n        storeData.persistentData[roomId][\"users\"][userId].rankNum == 1\n      ) {\n        //都落ちが発生。\n        //前回一位じゃなかったものが一位になっている場合は、都落ちが発生する。\n        LOGGER.debug(\"都落ち発生！！！\");\n        LOGGER.debug(\n          \"今の都落ち候補:\" + JSON.stringify(storeData.persistentData[roomId][\"users\"])\n        );\n        Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(key => {\n          if (storeData.persistentData[roomId][\"users\"][key].firstPlace) {\n            //都落ちなので、ゲーム終了。とりあえず大貧民にしておく\n            storeData.persistentData[roomId][\"users\"][key].rankNum = Object.keys(\n              storeData.persistentData[roomId][\"users\"]\n            ).length;\n            storeData.persistentData[roomId][\"users\"][key].rank =\n              storeData.persistentData[roomId][\"scoreTable\"][\n                Object.keys(storeData.persistentData[roomId][\"users\"]).length - 1\n              ].rankId;\n            storeData.persistentData[roomId][\"users\"][key].firstPlace = false;\n            storeData.persistentData[roomId][\"users\"][key].rankReason = \"fallingOutCity\";\n            storeData.persistentData[roomId][\"users\"][key].finishTime = new Date().getTime();\n            commonRequire.io.to(key).emit(\"finish\", {\n              rankReason: storeData.persistentData[roomId][\"users\"][key].rankReason\n            });\n            //みんなに知らせる\n            commonRequire.io.to(storeData.persistentData[roomId].roomId).emit(\"finishNotification\", {\n              playerName: storeData.persistentData[roomId][\"users\"][key].dispName,\n              rankReason: storeData.persistentData[roomId][\"users\"][key].rankReason\n            });\n            storeData.persistentData[roomId].finishNum = storeData.persistentData[roomId].finishNum + 1;\n            storeData.persistentData[roomId][\"order\"].splice(\n              storeData.persistentData[roomId][\"order\"].indexOf(key),\n              1\n            );\n          }\n        });\n      }\n      if (storeData.persistentData[roomId][\"users\"][userId].rankNum == 1) {\n        storeData.persistentData[roomId][\"users\"][userId].firstPlace = true;\n      }\n      storeData.persistentData[roomId].finishNum = storeData.persistentData[roomId].finishNum + 1;\n      storeData.persistentData[roomId].passCount = -1;\n\n      LOGGER.debug(\n        \"現在のユーザーの状態:\" +\n          JSON.stringify(storeData.persistentData[roomId][\"users\"][userId])\n      );\n      if (storeData.persistentData[roomId].finishNum == Object.keys(storeData.persistentData[roomId][\"users\"]).length){\n        //ここまでで決着がついた場合。(このパターンは結構特殊。4人プレイのときは先行して2人が反則負けで都落ちが発生するようなパターン。)\n        //つまり二人が同時にあがったりして、びり以外という判定ができないときに通る。\n        const reverseRank = aggregateBattlePhase(roomId);\n        storeData.persistentData[roomId][\"order\"] = reverseRank;\n        Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(function(key) {\n          storeData.persistentData[roomId][\"scoreTable\"].some(function(ele) {\n            if (storeData.persistentData[roomId][\"users\"][key].rank === ele.rankId) {\n              storeData.persistentData[roomId][\"users\"][key].point =\n                storeData.persistentData[roomId][\"users\"][key].point + ele.point;\n              LOGGER.debug(\n                storeData.persistentData[roomId][\"users\"][key].dispName +\n                  \"の現在のポイント: \" +\n                  storeData.persistentData[roomId][\"users\"][key].point\n              );\n              return true;\n            }\n          });\n        });\n        let displayRanking = [];\n        reverseRank.forEach(function(key) {\n          displayRanking.unshift({\n            rank: storeData.persistentData[roomId][\"users\"][key].rank,\n            dispName: storeData.persistentData[roomId][\"users\"][key].dispName\n          });\n        });\n        storeData.persistentData[roomId].rankingHistory.push({\n          gameNum : storeData.persistentData[roomId].gameNum,\n          ranking : displayRanking\n        });\n        if (storeData.persistentData[roomId].gameNum == 4) {\n          //1セット終了\n          let overallGrade = aggregateBattleSet(roomId);\n          let displayOverAllRanking = [];\n          overallGrade.forEach(function(key) {\n            displayOverAllRanking.push({\n              dispName: storeData.persistentData[roomId][\"users\"][key].dispName\n            });\n          });\n          for (let [key, value] of Object.entries(storeData.persistentData[roomId][\"users\"])) {\n            commonRequire.io.to(key).emit(\"gameSet\", {\n              gameNum: storeData.persistentData[roomId].gameNum,\n              ranking: displayRanking,\n              overall: displayOverAllRanking,\n              finalPoint: value.point\n            });\n          }\n          return;\n        } else {\n          //次のゲームへ\n          for (let [key, value] of Object.entries(storeData.persistentData[roomId][\"users\"])) {\n            commonRequire.io.to(key).emit(\"gameFinish\", {\n              gameNum: storeData.persistentData[roomId].gameNum,\n              ranking: displayRanking,\n              point: value.point\n            });\n          }\n          commonRequire.io.to(userId).emit(\"nextGameStart\", {\n            gameNum: storeData.persistentData[roomId].gameNum + 1,\n            ranking: displayRanking\n          });\n          storeData.persistentData[roomId].gameNum = storeData.persistentData[roomId].gameNum + 1;\n          return;\n        }\n      }\n      if (storeData.persistentData[roomId].finishNum == Object.keys(storeData.persistentData[roomId][\"users\"]).length - 1) {\n        //ビリ以外は全員終了\n        let lastId = Object.keys(storeData.persistentData[roomId][\"users\"]).filter(item => {\n          LOGGER.debug(\n            \"itemの値:\" + JSON.stringify(storeData.persistentData[roomId][\"users\"][item])\n          );\n          return storeData.persistentData[roomId][\"users\"][item].rank.length == 0;\n        });\n        LOGGER.debug(\n          \"最下位ユーザーに入るscoreTable:\" +\n            JSON.stringify(storeData.persistentData[roomId][\"scoreTable\"])\n        );\n        storeData.persistentData[roomId][\"users\"][lastId].rank =\n          storeData.persistentData[roomId][\"scoreTable\"][storeData.persistentData[roomId].rankCount - 1].rankId;\n        storeData.persistentData[roomId][\"users\"][lastId].rankNum = storeData.persistentData[roomId].rankCount;\n        storeData.persistentData[roomId][\"users\"][lastId].finishTime = new Date().getTime();\n        LOGGER.debug(\n          \"最下位ユーザー:\" + JSON.stringify(storeData.persistentData[roomId][\"users\"][lastId])\n        );\n        commonRequire.io.to(lastId).emit(\"finish\", {\n          rankReason: storeData.persistentData[roomId][\"users\"][lastId].rankReason\n        });\n        commonRequire.io.to(storeData.persistentData[roomId].roomId).emit(\"finishNotification\", {\n          playerName: storeData.persistentData[roomId][\"users\"][lastId].dispName,\n          rankReason: storeData.persistentData[roomId][\"users\"][lastId].rankReason\n        });\n        const reverseRank = aggregateBattlePhase(roomId);\n        storeData.persistentData[roomId][\"order\"] = reverseRank;\n        Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(function(key) {\n          storeData.persistentData[roomId][\"scoreTable\"].some(function(ele) {\n            if (storeData.persistentData[roomId][\"users\"][key].rank === ele.rankId) {\n              storeData.persistentData[roomId][\"users\"][key].point =\n                storeData.persistentData[roomId][\"users\"][key].point + ele.point;\n              LOGGER.debug(\n                storeData.persistentData[roomId][\"users\"][key].dispName +\n                  \"の現在のポイント: \" +\n                  storeData.persistentData[roomId][\"users\"][key].point\n              );\n              return true;\n            }\n          });\n        });\n        let displayRanking = [];\n        reverseRank.forEach(function(key) {\n          displayRanking.unshift({\n            rank: storeData.persistentData[roomId][\"users\"][key].rank,\n            dispName: storeData.persistentData[roomId][\"users\"][key].dispName\n          });\n        });\n        storeData.persistentData[roomId].rankingHistory.push({\n          gameNum : storeData.persistentData[roomId].gameNum,\n          ranking : displayRanking\n        });\n        if (storeData.persistentData[roomId].gameNum == 4) {\n          //1セット終了\n          let overallGrade = aggregateBattleSet(roomId);\n          let displayOverAllRanking = [];\n          overallGrade.forEach(function(key) {\n            displayOverAllRanking.push({\n              dispName: storeData.persistentData[roomId][\"users\"][key].dispName\n            });\n          });\n          for (let [key, value] of Object.entries(storeData.persistentData[roomId][\"users\"])) {\n            commonRequire.io.to(key).emit(\"gameSet\", {\n              gameNum: storeData.persistentData[roomId].gameNum,\n              ranking: displayRanking,\n              overall: displayOverAllRanking,\n              finalPoint: value.point\n            });\n          }\n          return;\n        } else {\n          //次のゲームへ\n          for (let [key, value] of Object.entries(storeData.persistentData[roomId][\"users\"])) {\n            commonRequire.io.to(key).emit(\"gameFinish\", {\n              gameNum: storeData.persistentData[roomId].gameNum,\n              ranking: displayRanking,\n              point: value.point\n            });\n            // if (key !== socketObj.id) io.to(key).emit(\"otherMemberJoinedRoom\", commonUtil.htmlentities(joinInfo.playerName));\n          }\n          // commonRequire.io.to(storeData.persistentData[roomId].roomId).emit(\"gameFinish\", {\n          //   gameNum: storeData.persistentData[roomId].gameNum,\n          //   ranking: displayRanking\n          // });\n          commonRequire.io.to(lastId).emit(\"nextGameStart\", {\n            gameNum: storeData.persistentData[roomId].gameNum + 1,\n            ranking: displayRanking\n          });\n          storeData.persistentData[roomId].gameNum = storeData.persistentData[roomId].gameNum + 1;\n          return;\n        }\n      }\n  notifyUtil.notifyChangeTurn(currentTurn, roomId);\n    //}\n}\n\nconst decideOrder = roomId => {\n  if (storeData.persistentData[roomId].gameNum == 1) {\n    //1回目の場合は部屋に入った順\n    Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(key => {\n      storeData.persistentData[roomId][\"order\"].push(key);\n    });\n    LOGGER.debug(\"第1回ゲームの順序: \" + storeData.persistentData[roomId][\"order\"]);\n  } else {\n    //2回目以降は大貧民が一番。時計回りという概念がないので、とりあえず順位の逆順にする。(オリジナル)\n    //TODO? 実際は大貧民から時計回り。\n    let userRank = [];\n    Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(key => {\n      userRank.push({ id: key, rankNum: storeData.persistentData[roomId][\"users\"][key].rankNum });\n      storeData.persistentData[roomId][\"users\"][key].rankNum = 0;\n      storeData.persistentData[roomId][\"users\"][key].rank = \"\";\n    });\n    userRank\n      .sort(function(a, b) {\n        if (a.rankNum > b.rankNum) return -1;\n        if (a.rankNum < b.rankNum) return 1;\n        return 0;\n      })\n      .forEach(key => {\n        LOGGER.debug(\"二回目以降key:\" + key);\n        storeData.persistentData[roomId][\"order\"].push(key.id);\n      });\n  }\n}\n\nconst handOutCards = (count, roomId) => {\n  let shuffleCards = commonUtil.sortArrayRandomly(ORIGINALCARDDATA);\n  const perNum = Math.floor(TRUMP_TEMP.total / count);\n  const remainder = TRUMP_TEMP.total % count;\n  LOGGER.debug(\"perNum:\" + perNum + \" remainder:\" + remainder);\n  //ブラインドカードの確認をする。もしジョーカーが含まれている場合は切りなおす。\n  while(shuffleCards.slice(TRUMP_TEMP.total - remainder, TRUMP_TEMP.total).some(ele => ~ele.type.indexOf(\"joker\"))){\n    LOGGER.debug(\"ブラインドカードにジョーカーが含まれるためシャッフルしなおす\" + JSON.stringify(shuffleCards.slice(TRUMP_TEMP.total - 2, TRUMP_TEMP.total)));\n    shuffleCards = commonUtil.sortArrayRandomly(ORIGINALCARDDATA);\n  }\n  let pos = 0;\n  Object.keys(storeData.persistentData[roomId][\"users\"]).forEach(key => {\n    storeData.persistentData[roomId][\"users\"][key].card = shuffleCards\n      //.slice(pos, remainder > 0 ? pos + perNum + 1 : pos + perNum)\n    .slice(pos, pos + perNum)\n      .sort(function(a, b) {\n        if (a.number < b.number) return -1;\n        if (a.number > b.number) return 1;\n        return 0;\n      });\n    \n    pos = pos + perNum;\n  });\n  //余ったカードがある場合、それはブラインドカードとする。\n  if(remainder !== 0){\n    storeData.persistentData[roomId].blindCards = shuffleCards.slice(pos, pos + remainder).sort(function(a, b) {\n        if (a.number < b.number) return -1;\n        if (a.number > b.number) return 1;\n        return 0;\n      });\n  }\n  LOGGER.debug(\n      \"ブラインドカード： \" + JSON.stringify(storeData.persistentData[roomId].blindCards)\n    );\n}\n\nconst trumpInit = (trumpData) => {\n  var cards = [];\n  for (var i = 0; i < trumpData[\"card\"].length; i++) {\n    var thistype = trumpData[\"card\"][i];\n    for (var j = 0; j < thistype[\"count\"]; j++) {\n      cards.push({\n        type: thistype[\"type\"],\n        number: j + 3\n      });\n    }\n  }\n  for (var i = 0; i < trumpData[\"joker\"]; i++) {\n    cards.push({\n      type: \"joker\" + (i + 1),\n      number: 99,\n      cloneType: \"\"\n    });\n  }\n  return cards;\n}\n\nconst checkRank = (sc, roomId, userId) => {\n  let result = checkFoul(sc, roomId);\n  if (result.foul) {\n    //反則上がりだった場合\n    //rankはとりあえず大貧民扱いとする。(あとで再計算する)\n    storeData.persistentData[roomId][\"users\"][userId].rank =\n      storeData.persistentData[roomId][\"scoreTable\"][\n        Object.keys(storeData.persistentData[roomId][\"users\"]).length - 1\n      ].rankId;\n    storeData.persistentData[roomId][\"users\"][userId].rankNum = Object.keys(\n      storeData.persistentData[roomId][\"users\"]\n    ).length;\n    //都落ちフラグは外しておく。(ないとは思うが、全員が反則上がりだった場合、大富豪になる可能性もある。そのときは別途firstPlaceを再計算する)\n    storeData.persistentData[roomId][\"users\"][userId].firstPlace = false;\n    storeData.persistentData[roomId][\"users\"][userId].rankReason = result.reason;\n    storeData.persistentData[roomId][\"users\"][userId].finishTime = new Date().getTime();\n  } else {\n    let nextRank = 0;\n    Object.keys(storeData.persistentData[roomId][\"users\"])\n      .sort(function(a, b) {\n        if (\n          storeData.persistentData[roomId][\"users\"][a].rankNum > storeData.persistentData[roomId][\"users\"][b].rankNum\n        )\n          return -1;\n        if (\n          storeData.persistentData[roomId][\"users\"][a].rankNum < storeData.persistentData[roomId][\"users\"][b].rankNum\n        )\n          return 1;\n        return 0;\n      })\n      .some(function(val) {\n        if (\n          storeData.persistentData[roomId][\"users\"][val].rankNum !=\n          Object.keys(storeData.persistentData[roomId][\"users\"]).length\n        ) {\n          nextRank = storeData.persistentData[roomId][\"users\"][val].rankNum + 1;\n          return true;\n        }\n      });\n\n    storeData.persistentData[roomId][\"users\"][userId].rank =\n      storeData.persistentData[roomId][\"scoreTable\"][nextRank - 1].rankId;\n    storeData.persistentData[roomId][\"users\"][userId].rankNum = nextRank;\n\n    storeData.persistentData[roomId][\"users\"][userId].rankReason = result.reason;\n    storeData.persistentData[roomId][\"users\"][userId].finishTime = new Date().getTime();\n    storeData.persistentData[roomId].rankCount = storeData.persistentData[roomId].rankCount + 1;\n  }\n}\n\n//反則上がりのチェック\nconst checkFoul = (sc, roomId) => {\n  let result = {\n    foul: false,\n    reason: \"\"\n  };\n  if (sc.length == 1 && sc[0].number == 3 && sc[0].type == \"spade\") {\n    //・スペ3一枚で上がってない？\n    result.foul = true;\n    result.reason = \"spade3Finish\";\n    return result;\n  }\n  //最後に出したカードに8またはジョーカーが含まれていない？(階段の場合は8は許される)\n  //あとで使う2と3と11backも確認しておく\n  let flag8 = false;\n  let flagJoker = false;\n  let flag2 = false;\n  let flag3 = false;\n  let flag11 = false;\n  sc.forEach(ele => {\n    if (ele.number == 8) {\n      flag8 = true;\n    }\n    if (~ele.type.indexOf(\"joker\")) {\n      flagJoker = true;\n    }\n    if (ele.number == 11) {\n      flag11 = true;\n    }\n    if (ele.number == 15) {\n      flag2 = true;\n    }\n    if (ele.number == 3) {\n      flag3 = true;\n    }\n  });\n  if (flagJoker) {\n    //最後に出したカードにJOKERを含む\n    result.foul = true;\n    result.reason = \"jokerFinish\";\n    return result;\n  }\n  if (flag11) {\n    //最後に出したカードに11を含む\n    result.foul = true;\n    result.reason = \"card11Finish\";\n    return result;\n  }\n  if (!storeData.persistentData[roomId].stair && flag8) {\n    //非階段状態で最後に出したカードに8を含む\n    result.foul = true;\n    result.reason = \"card8Finish\";\n    return result;\n  }\n\n  //排他的論理和で革命と11backによる2,3の判断をする。(記述を短くするためにビット演算する)\n  let xor = storeData.persistentData[roomId].revolution ^ storeData.persistentData[roomId].elevenback;\n  //革命時に3を含んでない?\n  if (xor == 1 && flag3) {\n    result.foul = true;\n    result.reason = \"card3Finish\";\n    return result;\n  }\n\n  //非革命時に2を含んでない？\n  if (xor == 0 && flag2) {\n    result.foul = true;\n    result.reason = \"card2Finish\";\n    return result;\n  }\n  return result;\n}\n\n//ゲームセットの成績統計\nconst aggregateBattleSet = (roomId) => {\n  //ポイント降順で返す。(ランキング順)\n  return Object.keys(storeData.persistentData[roomId][\"users\"]).sort(function(a, b) {\n    if (storeData.persistentData[roomId][\"users\"][a].point > storeData.persistentData[roomId][\"users\"][b].point)\n      return -1;\n    if (storeData.persistentData[roomId][\"users\"][a].point < storeData.persistentData[roomId][\"users\"][b].point)\n      return 1;\n    return 0;\n  });\n}\n\nconst aggregateBattlePhase = (roomId) => {\n  //ユーザデータを全検索し、最下位のメンバをfinishTimeの昇順に並べる。\n  let loseUsers = Object.keys(storeData.persistentData[roomId][\"users\"])\n    .filter(function(key) {\n      return storeData.persistentData[roomId][\"users\"][key].rankNum === 4;\n    })\n    .sort(function(a, b) {\n      if (\n        storeData.persistentData[roomId][\"users\"][a].finishTime <\n        storeData.persistentData[roomId][\"users\"][b].finishTime\n      )\n        return -1;\n      if (\n        storeData.persistentData[roomId][\"users\"][a].finishTime >\n        storeData.persistentData[roomId][\"users\"][b].finishTime\n      )\n        return 1;\n      return 0;\n    });\n  if (loseUsers.length != 1) {\n    //0はありえないので考慮しない。\n    LOGGER.debug(\"4位の人数: \" + loseUsers.length);\n    let pos = 0;\n    let fallingOutCityUserKey = \"\";\n    loseUsers.forEach(key => {\n      if (storeData.persistentData[roomId][\"users\"][key].rankReason != \"fallingOutCity\") {\n        //都落ちでない場合は、反則負けで早く上がったものから悪い順位になる。\n        LOGGER.debug(\n          \"入れる前: \" + JSON.stringify(storeData.persistentData[roomId][\"users\"][key])\n        );\n        storeData.persistentData[roomId][\"users\"][key].rankNum =\n          Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos;\n        if (storeData.persistentData[roomId][\"users\"][key].rankNum === 1) {\n          //(ないとは思うが)一位だった場合は都落ちフラグ\n          storeData.persistentData[roomId][\"users\"][key].firstPlace = true;\n          //Note 反則負け判断時にいったんフラグをfalseにしているので、ここで見直すことはしない\n        }\n        storeData.persistentData[roomId][\"users\"][key].rank =\n          storeData.persistentData[roomId][\"scoreTable\"][\n            Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos - 1\n          ].rankId;\n        LOGGER.debug(\n          \"入れた後: \" + JSON.stringify(storeData.persistentData[roomId][\"users\"][key])\n        );\n        pos++;\n      } else {\n        fallingOutCityUserKey = key;\n      }\n    });\n    if (fallingOutCityUserKey != \"\") {\n      LOGGER.debug(\"fallingOutCityUserKey:\" + fallingOutCityUserKey);\n      storeData.persistentData[roomId][\"users\"][fallingOutCityUserKey].rankNum =\n        Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos;\n      storeData.persistentData[roomId][\"users\"][fallingOutCityUserKey].rank =\n        storeData.persistentData[roomId][\"scoreTable\"][\n          Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos - 1\n        ].rankId;\n      LOGGER.debug(Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos - 1);\n      LOGGER.debug(\"都落ちユーザーの順位:\" + JSON.stringify(storeData.persistentData[roomId][\"users\"][fallingOutCityUserKey].rank));\n    }\n  }\n  //順位の逆順で返すと何かと楽そうなのでそうする。\n  //またこの時にサクッとpoint計上しておく\n  return Object.keys(storeData.persistentData[roomId][\"users\"]).sort(function(a, b) {\n    if (storeData.persistentData[roomId][\"users\"][a].rankNum > storeData.persistentData[roomId][\"users\"][b].rankNum)\n      return -1;\n    if (storeData.persistentData[roomId][\"users\"][a].rankNum < storeData.persistentData[roomId][\"users\"][b].rankNum)\n      return 1;\n    return 0;\n  });\n}\n\nconst ORIGINALCARDDATA = trumpInit(TRUMP_TEMP);\n\n//# sourceURL=webpack:///./src/server/gameUtil.js?");

/***/ }),

/***/ "./src/server/index.js":
/*!*****************************!*\
  !*** ./src/server/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst commonUtil = __webpack_require__(/*! ./commonUtil.js */ \"./src/server/commonUtil.js\");\nconst gameUtil = __webpack_require__(/*! ./gameUtil.js */ \"./src/server/gameUtil.js\");\nconst storeData = __webpack_require__(/*! ./storeData.js */ \"./src/server/storeData.js\");\nconst loggerUtil = __webpack_require__(/*! ./loggerUtil.js */ \"./src/server/loggerUtil.js\");\nconst LOGGER = loggerUtil.logger;\nconst commonRequire = __webpack_require__(/*! ./commonRequire.js */ \"./src/server/commonRequire.js\");\nconst notifyUtil = __webpack_require__(/*! ./notifyUtil.js */ \"./src/server/notifyUtil.js\");\nconst validateUtil = __webpack_require__(/*! ./validateUtil.js */ \"./src/server/validateUtil.js\");\n\nvar SocketEvent = __webpack_require__(/*! ./socketEvent */ \"./src/server/socketEvent.js\");\n//LOGGER.level = \"debug\";\n// io.set('heartbeat interval', 5000);\n// io.set('heartbeat timeout', 15000);\nvar port = process.env.PORT || 3000;\n//debug用フラグ\nconst debug = process.env.DEBUG === \"true\" ? true : false;\n\ncommonRequire.app.use(commonRequire.express.static(\"public\"));\n\n// commonRequire.app.get(\"/\", function(req, res) {\n//   res.sendFile(__dirname + \"/index.html\");\n// });\n// commonRequire.app.use(\"/css\", commonRequire.express.static(\"public/css\"));\n// commonRequire.app.use(\"/js\", commonRequire.express.static(\"public/js\"));\n\ncommonRequire.io.on(\"connection\", socket => {\n  //最初の接続時に現在のルーム一覧を送る\n  LOGGER.debug(JSON.stringify(storeData.persistentData));\n  commonRequire.io.to(socket.id).emit(\"showRoomList\", storeData.persistentData);\n\n  SocketEvent.load_common_event(socket);\n  SocketEvent.load_room_event(socket);\n  SocketEvent.load_game_event(socket);\n\n  //再戦\n  socket.on(\"rematch\", function(msg) {\n    const count = storeData.persistentData[msg.id].capacity;\n    if (Object.keys(storeData.persistentData[msg.id][\"users\"]).length == count) {\n      //人数がそろっているのか確認\n      gameUtil.gameInit(count, socket.nsp.adapter.rooms[msg.id].sockets, msg.id);\n    } else {\n      //TODO 解散\n      console.log(\"人数が足りないので解散する\");\n    }\n  });\n\n  socket.on(\"giveCardReady\", msg => {});\n  socket.on(\"giveToLowerStatus2\", msg => {\n    //大富豪から大貧民への送り\n    notifyUtil.notifyGameReady(msg.id);\n  });\n  socket.on(\"giveToLowerStatus1\", msg => {\n    //富豪から貧民への送り\n    notifyUtil.notifyGameReady(msg.id);\n  });\n\n  socket.on(\"validate\", function(msg) {\n    const orderList = storeData.persistentData[msg.id][\"order\"];\n    const users = storeData.persistentData[msg.id][\"users\"];\n    let currentTurn = orderList.indexOf(socket.id);\n    //最初に来たカードは昇順ソートしておく。(念のため)\n    let validateCards = msg.cards.sort(function(a, b) {\n      if (a.number < b.number) return -1;\n      if (a.number > b.number) return 1;\n      return 0;\n    });\n    let fieldCards = storeData.persistentData[msg.id][\"fieldCards\"];\n\n    /* 受け取ったカードのみで判定可能な部分 */\n    //役をチェック\n    let resultCheckHand = validateUtil.checkValidateHand(validateCards);\n    if (resultCheckHand.error !== 0) {\n      commonRequire.io.to(socket.id).emit(\"validateError\", {\n        card: msg,\n        error: 1,\n        reason: \"handError\"\n      });\n      return;\n    }\n\n    /* 場のカードとの比較判定 */\n    LOGGER.debug(\"場のカード:\" + JSON.stringify(fieldCards));\n    const resultCardCompare = cardCompareValidate(\n      fieldCards,\n      validateCards,\n      resultCheckHand.type,\n      msg.id\n    );\n    if (resultCardCompare.error != 0) {\n      commonRequire.io.to(socket.id).emit(\"validateError\", {\n        card: msg,\n        error: 1,\n        reason: resultCardCompare.reason\n      });\n      return;\n    }\n    if (fieldCards.length != 0) {\n      if (\n        ~fieldCards[0].type.indexOf(\"joker\") &&\n        validateCards[0].type == \"spade\" &&\n        validateCards[0].number == \"3\"\n      ) {\n        //JOKER討伐(誰も倒せないから流す)\n        storeData.fieldClear(msg.id);\n        commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", {\n          type: \"winjoker\",\n          value: msg,\n          playerName: users[socket.id].dispName\n        });\n        //ストアからカードを抜きだす\n        removeCard(validateCards, socket.id, msg.id);\n        if (users[socket.id].card.length <= 0) {\n          gameUtil.checkOut(validateCards, msg.id, socket.id, currentTurn);\n          //notifyUtil.notifyChangeTurn(currentTurn, msg.id);\n        }else{\n          notifyUtil.notifyAgainTurn(msg.id, socket.id);\n        }\n        return;\n      }\n      const shibariResult = checkShibari(fieldCards, validateCards);\n      if (!storeData.persistentData[msg.id].shibari && shibariResult.isShibari) {\n        storeData.persistentData[msg.id].shibari = true;\n        storeData.persistentData[msg.id].shibariSuites = shibariResult.suites;\n        commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", {\n          type: \"shibari\",\n          value: storeData.persistentData[msg.id].shibari,\n          playerName: users[socket.id].dispName,\n          suites: shibariResult.suites\n        });\n      }\n    }\n\n    if (\n      validateCards.length == 2 &&\n      ~validateCards[0].type.indexOf(\"joker\") &&\n      ~validateCards[1].type.indexOf(\"joker\")\n    ) {\n      //JOKER2枚だしは歯が立たないので流す\n      storeData.fieldClear(msg.id);\n      commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", {\n        type: \"doblejoker\",\n        value: msg,\n        playerName: users[socket.id].dispName\n      });\n      removeCard(validateCards, socket.id, msg.id);\n      if (users[socket.id].card.length <= 0) {\n          gameUtil.checkOut(validateCards, msg.id, socket.id, currentTurn);\n          //notifyUtil.notifyChangeTurn(currentTurn, msg.id);\n        }else{\n          notifyUtil.notifyAgainTurn(msg.id, socket.id);\n        }\n      return;\n    }\n    if (validateCards.length >= 4 && resultCheckHand.type !== \"stair\") {\n      //革命(階段革命はない)\n      storeData.persistentData[msg.id].revolution = !storeData.persistentData[msg.id].revolution;\n      commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", {\n        type: \"revolution\",\n        value: storeData.persistentData[msg.id].revolution,\n        playerName: users[socket.id].dispName\n      });\n    }\n    if (validateCards[0].number == 8 && resultCheckHand.type !== \"stair\") {\n      //8ぎり(階段のときは発生しない)\n      storeData.fieldClear(msg.id);\n      commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", {\n        type: \"cut8\",\n        value: msg,\n        playerName: users[socket.id].dispName\n      });\n      removeCard(validateCards, socket.id, msg.id);\n      if (users[socket.id].card.length <= 0) {\n          gameUtil.checkOut(validateCards, msg.id, socket.id, currentTurn);\n          //notifyUtil.notifyChangeTurn(currentTurn, msg.id);\n        }else{\n          notifyUtil.notifyAgainTurn(msg.id, socket.id);\n        }\n      return;\n    }\n    if (validateCards[0].number == 11 && resultCheckHand.type !== \"stair\") {\n      //11back\n      storeData.persistentData[msg.id].elevenback = !storeData.persistentData[msg.id].elevenback;\n      commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", {\n        type: \"elevenback\",\n        value: storeData.persistentData[msg.id].elevenback,\n        playerName: users[socket.id].dispName\n      });\n    }\n    storeData.persistentData[msg.id].passCount = 0;\n    storeData.persistentData[msg.id][\"fieldCards\"] = validateCards;\n    if (resultCheckHand.type === \"stair\") {\n      //階段役だった場合はフラグを立てる\n      storeData.persistentData[msg.id].stair = true;\n    }\n    commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"result\", {\n      card: validateCards,\n      error: 0,\n      reason: \"\",\n      result: storeData.persistentData[msg.id][\"fieldCards\"],\n      playerName: users[socket.id].dispName\n    });\n\n    removeCard(validateCards, socket.id, msg.id);\n    if (users[socket.id].card.length <= 0) {\n      //上がった場合\n      gameUtil.checkOut(validateCards, msg.id, socket.id, currentTurn);\n    }else{\n      //上がっていない場合は次の順番に回す処理のみ\n      notifyUtil.notifyChangeTurn(currentTurn, msg.id);\n    }\n  });\n  socket.on(\"selectedGiveCard\", msg => {\n    //選択したカードを交換して、ゲームをスタートする。\n\n    //あげたカードを消す\n    removeCard(msg.cards, socket.id, msg.id);\n    //自分のランク\n    let myOrder = storeData.persistentData[msg.id][\"order\"].indexOf(socket.id);\n    let yourOrder = storeData.persistentData[msg.id].capacity - myOrder - 1;\n    //let lower = store[msg.id]['order']\n    storeData.persistentData[msg.id][\"users\"][socket.id].giveCard = msg.cards;\n    //人数により相手が異なる。\n    if (storeData.persistentData[msg.id].capacity === 3) {\n      //もらうカードを増やす\n      storeData.persistentData[msg.id][\"users\"][socket.id].card.push(\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard[0]\n      );\n      //もらったカードは向こうのユーザーから消す\n      removeCard(\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard,\n        storeData.persistentData[msg.id][\"order\"][yourOrder],\n        msg.id\n      );\n      //storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard = [];\n      storeData.persistentData[msg.id][\"users\"][socket.id].getCard = storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard;\n      //こちらのカードを相手に渡す。\n      storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].card.push(\n        msg.cards[0]\n      );\n      storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].getCard = msg.cards;\n      storeData.sortCard(msg.id, socket.id, true);\n      storeData.sortCard(msg.id, storeData.persistentData[msg.id][\"order\"][yourOrder], true);\n\n      storeData.persistentData[msg.id].giveCardCount = storeData.persistentData[msg.id].giveCardCount + 1;\n      if (storeData.persistentData[msg.id].giveCardCount == 1) {\n        storeData.persistentData[msg.id].giveCardPhase = false;  //譲渡フェーズ終了\n        notifyUtil.notifyGameReady(msg.id);\n      } else {\n        //TODO 何か送ってもいいかもしれないが、いったん保留で\n      }\n    } else {\n      if (yourOrder === 0) {\n        //大貧民とのやりとり\n        storeData.persistentData[msg.id][\"users\"][socket.id].card.push(\n          storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard[0]\n        );\n        storeData.persistentData[msg.id][\"users\"][socket.id].card.push(\n          storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard[1]\n        );\n        //もらったカードは向こうのユーザーから消す\n        removeCard(\n          storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard,\n          storeData.persistentData[msg.id][\"order\"][yourOrder],\n          msg.id\n        );\n        //storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard = [];\n        storeData.persistentData[msg.id][\"users\"][socket.id].getCard = storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard;\n        //こちらのカードを相手に渡す。\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].card.push(\n          msg.cards[0]\n        );\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].card.push(\n          msg.cards[1]\n        );\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].getCard = msg.cards;\n      } else if (yourOrder === 1) {\n        //貧民とのやりとり\n        storeData.persistentData[msg.id][\"users\"][socket.id].card.push(\n          storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard[0]\n        );\n        //もらったカードは向こうのユーザーから消す\n        removeCard(\n          storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard,\n          storeData.persistentData[msg.id][\"order\"][yourOrder],\n          msg.id\n        );\n        //storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard = [];\n        storeData.persistentData[msg.id][\"users\"][socket.id].getCard = storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].giveCard;\n        //こちらのカードを相手に渡す。\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].card.push(\n          msg.cards[0]\n        );\n        storeData.persistentData[msg.id][\"users\"][storeData.persistentData[msg.id][\"order\"][yourOrder]].getCard = msg.cards;\n      }\n      storeData.sortCard(msg.id, socket.id, true);\n      storeData.sortCard(msg.id, storeData.persistentData[msg.id][\"order\"][yourOrder], true);\n      storeData.persistentData[msg.id].giveCardCount = storeData.persistentData[msg.id].giveCardCount + 1;\n\n      if (storeData.persistentData[msg.id].giveCardCount == 2) {\n        storeData.persistentData[msg.id].giveCardPhase = false;  //譲渡フェーズ終了\n        notifyUtil.notifyGameReady(msg.id);\n      } else {\n        //TODO 何か送ってもいいかもしれないが、いったん保留で\n      }\n    }\n  });\n});\n\n//ゲームセットの成績統計\nfunction aggregateBattleSet(roomId) {\n  //ポイント降順で返す。(ランキング順)\n  return Object.keys(storeData.persistentData[roomId][\"users\"]).sort(function(a, b) {\n    if (storeData.persistentData[roomId][\"users\"][a].point > storeData.persistentData[roomId][\"users\"][b].point)\n      return -1;\n    if (storeData.persistentData[roomId][\"users\"][a].point < storeData.persistentData[roomId][\"users\"][b].point)\n      return 1;\n    return 0;\n  });\n}\n\nfunction aggregateBattlePhase(roomId) {\n  //ユーザデータを全検索し、最下位のメンバをfinishTimeの昇順に並べる。\n  let loseUsers = Object.keys(storeData.persistentData[roomId][\"users\"])\n    .filter(function(key) {\n      return storeData.persistentData[roomId][\"users\"][key].rankNum === 4;\n    })\n    .sort(function(a, b) {\n      if (\n        storeData.persistentData[roomId][\"users\"][a].finishTime <\n        storeData.persistentData[roomId][\"users\"][b].finishTime\n      )\n        return -1;\n      if (\n        storeData.persistentData[roomId][\"users\"][a].finishTime >\n        storeData.persistentData[roomId][\"users\"][b].finishTime\n      )\n        return 1;\n      return 0;\n    });\n  if (loseUsers.length != 1) {\n    //0はありえないので考慮しない。\n    LOGGER.debug(\"4位の人数: \" + loseUsers.length);\n    let pos = 0;\n    let fallingOutCityUserKey = \"\";\n    loseUsers.forEach(key => {\n      if (storeData.persistentData[roomId][\"users\"][key].rankReason != \"fallingOutCity\") {\n        //都落ちでない場合は、反則負けで早く上がったものから悪い順位になる。\n        LOGGER.debug(\n          \"入れる前: \" + JSON.stringify(storeData.persistentData[roomId][\"users\"][key])\n        );\n        storeData.persistentData[roomId][\"users\"][key].rankNum =\n          Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos;\n        if (storeData.persistentData[roomId][\"users\"][key].rankNum === 1) {\n          //(ないとは思うが)一位だった場合は都落ちフラグ\n          storeData.persistentData[roomId][\"users\"][key].firstPlace = true;\n          //Note 反則負け判断時にいったんフラグをfalseにしているので、ここで見直すことはしない\n        }\n        storeData.persistentData[roomId][\"users\"][key].rank =\n          storeData.persistentData[roomId][\"scoreTable\"][\n            Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos - 1\n          ].rankId;\n        LOGGER.debug(\n          \"入れた後: \" + JSON.stringify(storeData.persistentData[roomId][\"users\"][key])\n        );\n        pos++;\n      } else {\n        fallingOutCityUserKey = key;\n      }\n    });\n    if (fallingOutCityUserKey != \"\") {\n      storeData.persistentData[roomId][\"users\"][fallingOutCityUserKey].rankNum =\n        Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos;\n      storeData.persistentData[roomId][\"users\"][fallingOutCityUserKey].rank =\n        storeData.persistentData[roomId][\"scoreTable\"][\n          Object.keys(storeData.persistentData[roomId][\"users\"]).length - pos - 1\n        ];\n    }\n  }\n  //順位の逆順で返すと何かと楽そうなのでそうする。\n  //またこの時にサクッとpoint計上しておく\n  return Object.keys(storeData.persistentData[roomId][\"users\"]).sort(function(a, b) {\n    if (storeData.persistentData[roomId][\"users\"][a].rankNum > storeData.persistentData[roomId][\"users\"][b].rankNum)\n      return -1;\n    if (storeData.persistentData[roomId][\"users\"][a].rankNum < storeData.persistentData[roomId][\"users\"][b].rankNum)\n      return 1;\n    return 0;\n  });\n}\n\nfunction checkShibari(ncs, scs) {\n  let result = {\n    isShibari : false,\n    suites: []\n  }\n  if (\n    scs.some(item => ~item.type.indexOf(\"joker\")) ||\n    ncs.some(item => ~item.type.indexOf(\"joker\"))\n  ) {\n    //return false;\n    return result;\n  }\n  var flag = false;\n  let suiteArr = [];\n  for (let i = 0; i < ncs.length; i++) {\n    flag = scs.some(item => {\n      if(item.type === ncs[i].type){\n        suiteArr.push(item.type);\n        return true;\n      }\n    });\n    if (!flag) {\n      //一回でも一致しなければfalse\n      return result;\n    }\n  }\n  result.isShibari = true;\n  result.suites = suiteArr;\n  return result;\n}\n\nfunction isSameNumber(cards) {\n  let base = cards[0].number;\n  if (cards.length == 1) {\n    return true;\n  }\n  for (let i = 1; i < cards.length; i++) {\n    if (~cards[i].type.indexOf(\"joker\")) {\n      continue;\n    }\n    if (base != cards[i].number) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction removeCard(sc, userId, roomId) {\n  LOGGER.debug(\n    \"カード削除前: \" + JSON.stringify(storeData.persistentData[roomId][\"users\"][userId].card)\n  );\n  sc.forEach(v => {\n    storeData.persistentData[roomId][\"users\"][userId].card = storeData.persistentData[roomId][\"users\"][\n      userId\n    ].card.filter(ele => {\n      return v.type !== ele.type || v.number !== ele.number;\n    });\n  });\n  LOGGER.debug(\n    \"カード削除後: \" + JSON.stringify(storeData.persistentData[roomId][\"users\"][userId].card)\n  );\n}\n\nfunction cardCompareValidate(nc, sc, handType, roomId) {\n  let result = {\n    card: [],\n    error: 0,\n    reason: \"\"\n  };\n  if (nc.length === 0) {\n    //初回のカード(つまり比べるものがない)場合は問題なしとしてデフォルトで返す。\n    return result;\n  }\n  //枚数が等しいことをチェック\n  if (nc.length != sc.length) {\n    result.card = sc;\n    result.error = 1;\n    result.reason = \"diffNumOfCards\";\n    return result;\n  }\n  //スート縛りの確認\n  if (storeData.persistentData[roomId].shibari && !isSameType(nc, sc)) {\n    result.card = sc;\n    result.error = 1;\n    result.reason = \"diffSuitCards\";\n    return result;\n  }\n  //数字の大小確認\n  if (!numComparison(nc, sc, roomId)) {\n    //複数枚の時はすべての数字が同じなので1枚目をみれば良い\n    //階段の場合も一番弱いカード\n    result.card = sc;\n    result.error = 1;\n    result.reason = \"loseCards\";\n    return result;\n  }\n  return result;\n}\n\nfunction numComparison(nc, sc, roomId) {\n  let checkNC;\n  let checkSC;\n  if (\n    storeData.persistentData[roomId].stair &&\n    (storeData.persistentData[roomId].elevenback || storeData.persistentData[roomId].revolution)\n  ) {\n    //階段の場合、革命または11Back時の動作が変わる。(一番大きい数字を見ないといけない)\n    nc.some(ele => {\n      if (~ele.type.indexOf(\"joker\")) {\n        return true;\n      } else {\n        checkNC = ele;\n      }\n    });\n    sc.some(ele => {\n      if (~ele.type.indexOf(\"joker\")) {\n        return true;\n      } else {\n        checkSC = ele;\n      }\n    });\n  } else {\n    checkNC = nc[0];\n    checkSC = sc[0];\n  }\n  LOGGER.debug(\n    \"numComparisonの比較対象checkNC：\" + checkNC + \"　checkSC:\" + checkSC\n  );\n  if (~checkNC.type.indexOf(\"joker\") && ~checkSC.type.indexOf(\"joker\")) {\n    //ジョーカーはジョーカーに勝てない\n    return false;\n  }\n  if (\n    ~checkNC.type.indexOf(\"joker\") &&\n    checkSC.type == \"spade\" &&\n    checkSC.number == \"3\"\n  ) {\n    //スペ3はジョーカーに勝てる\n    return true;\n  }\n  if (\n    ~checkSC.type.indexOf(\"joker\") &&\n    checkNC.type == \"spade\" &&\n    checkNC.number == \"3\"\n  ) {\n    //ジョーカーはスペ3に勝てない\n    return false;\n  }\n  if (storeData.persistentData[roomId].elevenback && storeData.persistentData[roomId].revolution) {\n    LOGGER.debug(\"11backかつ革命中\");\n    return checkNC.number < checkSC.number;\n  } else if (storeData.persistentData[roomId].elevenback || storeData.persistentData[roomId].revolution) {\n    LOGGER.debug(\"11backまたは革命中\");\n    LOGGER.debug(\"比較させてねcheckNC\" + JSON.stringify(checkNC));\n    LOGGER.debug(\"比較させてねcheckSC\" + JSON.stringify(checkSC));\n    //逆残\n    if (~checkSC.type.indexOf(\"joker\")) {\n      //ジョーカーは必ず勝てる\n      return true;\n    }\n    return checkNC.number > checkSC.number;\n  } else {\n    return checkNC.number < checkSC.number;\n  }\n}\n\nfunction isSameType(ncs, scs) {\n  //まずジョーカーの数を数える\n  let jokerCount = scs.filter(item => ~item.type.indexOf(\"joker\")).length;\n  var flag = false;\n  for (let i = 0; i < ncs.length; i++) {\n    flag = scs.some(item => item.type === ncs[i].type);\n    if (!flag) {\n      if (jokerCount > 0) {\n        //Joker置き換え\n        flag = true;\n        jokerCount--;\n        continue;\n      } else {\n        if (~ncs[i].type.indexOf(\"joker\")) {\n          //相手がjokerだった場合は好きなマークで置き換え可能\n          flag = true;\n          continue;\n        } else {\n          //一回でも一致しなければfalse\n          return false;\n        }\n      }\n    }\n  }\n  return flag;\n}\n\ncommonRequire.http.listen(port, function() {\n  console.log(\"listening on *:\" + port);\n});\n\n\n//# sourceURL=webpack:///./src/server/index.js?");

/***/ }),

/***/ "./src/server/loggerUtil.js":
/*!**********************************!*\
  !*** ./src/server/loggerUtil.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const log4js = __webpack_require__(/*! log4js */ \"log4js\");\nmodule.exports.logger = log4js.getLogger();\n\nmodule.exports.logger.level = \"debug\";\n\n//# sourceURL=webpack:///./src/server/loggerUtil.js?");

/***/ }),

/***/ "./src/server/notifyUtil.js":
/*!**********************************!*\
  !*** ./src/server/notifyUtil.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst commonRequire = __webpack_require__(/*! ./commonRequire.js */ \"./src/server/commonRequire.js\");\nconst commonUtil = __webpack_require__(/*! ./commonUtil.js */ \"./src/server/commonUtil.js\");\nconst gameUtil = __webpack_require__(/*! ./gameUtil.js */ \"./src/server/gameUtil.js\");\nconst storeData = __webpack_require__(/*! ./storeData.js */ \"./src/server/storeData.js\");\nconst loggerUtil = __webpack_require__(/*! ./loggerUtil.js */ \"./src/server/loggerUtil.js\");\nconst LOGGER = loggerUtil.logger;\nconst io = commonRequire.io;\n\nmodule.exports.notifyGameReady = roomId => {\n  storeData.persistentData[roomId].giveCardCount = 0;\n  const orders = storeData.persistentData[roomId][\"order\"];\n  const users = storeData.persistentData[roomId][\"users\"];\n  const userDispList = [];\n  orders.forEach(key => {\n    userDispList.push(users[key].dispName);\n  });\n  // for (let [key, value] of Object.entries(orders)) {\n  //   userDispList.push(value.dispName);\n  // }\n  io.to(orders[0]).emit(\"gameReady\", {\n    gameNum: storeData.persistentData[roomId].gameNum,\n    card: users[orders[0]].card,\n    yourTurn: true,\n    playerName: users[orders[0]].dispName,\n    playerName2: users[orders[0]].dispName,\n    playerPoint: users[orders[0]].point,\n    blindCards: storeData.persistentData[roomId].blindCards,\n    orderNum: 0,\n    userList: userDispList\n  });\n  LOGGER.debug(\n    \"gameReadyのレスポンス(一番目)： \" +\n      JSON.stringify({\n        gameNum: storeData.persistentData[roomId].gameNum,\n        card: users[orders[0]].card,\n        yourTurn: true,\n        playerName: users[orders[0]].dispName\n      })\n  );\n  for (let i = 1; i < storeData.persistentData[roomId][\"order\"].length; i++) {\n    io.to(orders[i]).emit(\"gameReady\", {\n      gameNum: storeData.persistentData[roomId].gameNum,\n      card: users[orders[i]].card,\n      yourTurn: false,\n      playerName: users[orders[0]].dispName,\n      playerName2: users[orders[i]].dispName,\n      playerPoint: users[orders[i]].point,\n      blindCards: storeData.persistentData[roomId].blindCards,\n      orderNum: 0,\n      userList: userDispList\n    });\n    LOGGER.debug(\n      \"gameReadyのレスポンス(二番目以降)： \" +\n        JSON.stringify({\n          card: users[orders[i]].card,\n          yourTurn: false,\n          playerName: users[orders[0]].dispName\n        })\n    );\n  }\n}\n\nmodule.exports.notifyGiveCard = (roomId,playerNum) => {\n  storeData.persistentData[roomId].giveCardPhase = true;\n  if (playerNum === 3) {\n    //3人のとき\n    const LowerUser1 = storeData.persistentData[roomId][\"order\"][0];\n    const HigherUser1 = storeData.persistentData[roomId][\"order\"][2];\n    commonRequire.io.to(HigherUser1).emit(\"giveToLowerStatus1\", {\n      targetCard: storeData.persistentData[roomId][\"users\"][HigherUser1].card\n    });\n    commonRequire.io.to(LowerUser1).emit(\"giveToHigherStatus1\", {\n      targetCard: [storeData.persistentData[roomId][\"users\"][LowerUser1].card.slice(-1)[0]]\n    });\n    storeData.persistentData[roomId][\"users\"][LowerUser1].giveCard.push(\n      storeData.persistentData[roomId][\"users\"][LowerUser1].card.slice(-1)[0]\n    );\n  } else {\n    //4人以上\n    const LowerUser1 = storeData.persistentData[roomId][\"order\"][1];\n    const HigherUser1 = storeData.persistentData[roomId][\"order\"][playerNum - 2];\n    const LowerUser2 = storeData.persistentData[roomId][\"order\"][0];\n    const HigherUser2 = storeData.persistentData[roomId][\"order\"][playerNum - 1];\n    commonRequire.io.to(HigherUser2).emit(\"giveToLowerStatus2\", {\n      targetCard: commonUtil.sortArray(storeData.persistentData[roomId][\"users\"][HigherUser2].card, true)\n    });\n    commonRequire.io.to(LowerUser2).emit(\"giveToHigherStatus2\", {\n      targetCard: commonUtil.sortArray([\n        storeData.persistentData[roomId][\"users\"][LowerUser2].card.slice(-1)[0],\n        storeData.persistentData[roomId][\"users\"][LowerUser2].card.slice(-2)[0]\n      ], true)\n    });\n    commonRequire.io.to(HigherUser1).emit(\"giveToLowerStatus1\", {\n      targetCard: storeData.persistentData[roomId][\"users\"][HigherUser1].card\n    });\n    commonRequire.io.to(LowerUser1).emit(\"giveToHigherStatus1\", {\n      targetCard: [storeData.persistentData[roomId][\"users\"][LowerUser1].card.slice(-1)[0]]\n    });\n    storeData.persistentData[roomId][\"users\"][LowerUser1].giveCard.push(\n      storeData.persistentData[roomId][\"users\"][LowerUser1].card.slice(-1)[0]\n    );\n    storeData.persistentData[roomId][\"users\"][LowerUser2].giveCard.push(\n      storeData.persistentData[roomId][\"users\"][LowerUser2].card.slice(-1)[0]\n    );\n    storeData.persistentData[roomId][\"users\"][LowerUser2].giveCard.push(\n      storeData.persistentData[roomId][\"users\"][LowerUser2].card.slice(-2)[0]\n    );\n  }\n}\n\nmodule.exports.notifyChangeTurn = (currentTurnIndex, roomId) => {\n  const orderList = storeData.persistentData[roomId][\"order\"];\n  const users = storeData.persistentData[roomId][\"users\"]; \n  let nextTurn =\n    currentTurnIndex != orderList.length - 1 ? currentTurnIndex + 1 : 0;\n  let nextTurnUserId = orderList[nextTurn];\n  let currentTurnUserId = orderList[currentTurnIndex];\n  const remainingCards = [];\n  if (users[orderList[currentTurnIndex]].rankNum != 0) {\n    //現在のユーザがすでに上がっている場合\n    storeData.persistentData[roomId][\"order\"].splice(currentTurnIndex, 1);\n  }\n  orderList.forEach(key => {\n    remainingCards.push({\n      cardNum: users[key].card.length,\n      playerName: users[key].dispName\n    });\n  });\n\n  Object.keys(users).forEach(function(element) {\n    //if (element != orderList[nextTurn]) {\n    if(element != nextTurnUserId){\n      commonRequire.io.to(element).emit(\"order\", {\n        flag: false,\n        skip: false,\n        //playerName: users[orderList[nextTurn]].dispName,\n        playerName: users[nextTurnUserId].dispName,\n        orderNum: storeData.persistentData[roomId][\"order\"].indexOf(nextTurnUserId),\n        endCurrentTurn: users[currentTurnUserId].rankNum != 0 ? currentTurnIndex : -1,\n        orders: remainingCards\n      });\n    }\n  });\n  commonRequire.io.to(nextTurnUserId).emit(\"order\", {\n    flag: true,\n    skip: users[nextTurnUserId].rank != \"\" ? true : false,\n    orderNum: storeData.persistentData[roomId][\"order\"].indexOf(nextTurnUserId),\n    endCurrentTurn: users[currentTurnUserId].rankNum != 0 ? currentTurnIndex : -1,\n    orders: remainingCards\n  });\n  storeData.persistentData[roomId].currentTurnPos = storeData.persistentData[roomId][\"order\"].indexOf(nextTurnUserId);\n  // if (users[orderList[currentTurnIndex]].rankNum != 0) {\n  //   //現在のユーザがすでに上がっている場合\n  //   storeData.persistentData[roomId][\"order\"].splice(currentTurnIndex, 1);\n  // }\n  //storeData.persistentData[roomId].currentTurnPos = currentTurnIndex != orderList.length - 1 ? currentTurnIndex + 1 : 0\n}\n\nmodule.exports.notifyAgainTurn = (roomId, userId) => {\n  const orderList = storeData.persistentData[roomId][\"order\"];\n  const users = storeData.persistentData[roomId][\"users\"]; \n  const remainingCards = [];\n  orderList.forEach(key => {\n    remainingCards.push({\n      cardNum: users[key].card.length,\n      playerName: users[key].dispName\n    });\n  });\n  for (let [key, value] of Object.entries(storeData.persistentData[roomId][\"users\"])) {\n    if(key === userId){\n      commonRequire.io.to(userId).emit(\"againTurn\", {\n        orderNum: storeData.persistentData[roomId][\"order\"].indexOf(userId),\n        orders: remainingCards\n      });\n    }else{\n      commonRequire.io.to(key).emit(\"againTurnForOtherMember\", {\n        orderNum: storeData.persistentData[roomId][\"order\"].indexOf(userId),\n        orders: remainingCards\n      });\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/server/notifyUtil.js?");

/***/ }),

/***/ "./src/server/roomUtil.js":
/*!********************************!*\
  !*** ./src/server/roomUtil.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst commonUtil = __webpack_require__(/*! ./commonUtil.js */ \"./src/server/commonUtil.js\");\nconst gameUtil = __webpack_require__(/*! ./gameUtil.js */ \"./src/server/gameUtil.js\");\nconst storeData = __webpack_require__(/*! ./storeData.js */ \"./src/server/storeData.js\");\nconst commonRequire = __webpack_require__(/*! ./commonRequire.js */ \"./src/server/commonRequire.js\");\nconst loggerUtil = __webpack_require__(/*! ./loggerUtil.js */ \"./src/server/loggerUtil.js\");\nconst LOGGER = loggerUtil.logger;\nconst io = commonRequire.io;\n\n// let roomObjectTemp = {\n//   roomId: \"\", //部屋を一意に決めるID\n//   roomDispName: \"\", //部屋の表示名\n//   capacity: 0, //部屋の定員数\n//   gameNum: 1, //ゲーム回\n//   passCount: 0, //パス数\n//   elevenback: false, //11backフラグ\n//   shibari: false, //縛りフラグ\n//   revolution: false, //革命フラグ\n//   stair: false, //階段フラグ\n//   fieldCards: [], //場のカード配列\n//   scoreTable: [], //階級別のスコアテーブル\n//   finishNum: 0, //上がったプレイヤーの数\n//   order: [], //順番\n//   currentTurnPos: 0, //今order配列上何番目の人のターンか\n//   startedGame: false, //ゲームが開始されているか否かのフラグ\n//   rankCount: 1, //次に割り当てられる順位\n//   giveCardCount: 0, //カードを譲渡を実施した回数(最大2回想定)\n//   users: {}, //ユーザ情報\n//   blindCards: [], //ブラインドカード\n//   leaveUserIds: []  //抜けた人のid\n// };\n\nmodule.exports.createRoom = roomInfo => {\n  const createRoomId = commonUtil.createUniqueId();\n  let roomObj = {\n  roomId: \"\", //部屋を一意に決めるID\n  roomDispName: \"\", //部屋の表示名\n  capacity: 0, //部屋の定員数\n  gameNum: 1, //ゲーム回\n  passCount: 0, //パス数\n  elevenback: false, //11backフラグ\n  shibari: false, //縛りフラグ\n  shibariSuites: [], //縛りマーク一覧\n  revolution: false, //革命フラグ\n  stair: false, //階段フラグ\n  fieldCards: [], //場のカード配列\n  scoreTable: [], //階級別のスコアテーブル\n  finishNum: 0, //上がったプレイヤーの数\n  order: [], //順番\n  currentTurnPos: 0, //今order配列上何番目の人のターンか\n  startedGame: false, //ゲームが開始されているか否かのフラグ\n  giveCardPhase: false, //カード譲渡フェーズかどうかのフラグ\n  rankCount: 1, //次に割り当てられる順位\n  giveCardCount: 0, //カードを譲渡を実施した回数(最大2回想定)\n  users: {}, //ユーザ情報\n  blindCards: [], //ブラインドカード\n  leaveUserIds: [],  //抜けた人のid\n  rankingHistory: [],  //ランキングの配列\n  status: \"recruiting\"\n};\n  roomObj[\"roomId\"] = createRoomId;\n  roomObj[\"roomDispName\"] = roomInfo.dispName === \"\" ? createDefaultRoomName() : commonUtil.htmlentities(roomInfo.dispName);\n  roomObj[\"capacity\"] = roomInfo.capacity === \"\" ? 4 : Number(roomInfo.capacity);\n  storeData.persistentData[createRoomId] = roomObj;\n  LOGGER.info(\"createdRoom:  \" + roomObj.roomDispName);\n  io.emit(\"createdRoom\", { [createRoomId]: roomObj });\n};\n\nmodule.exports.joinRoom = (joinInfo, socketObj) => {\n  const roomCapacity = storeData.persistentData[joinInfo.roomId].capacity;\n    if (Object.keys(storeData.persistentData[joinInfo.roomId][\"users\"]).length >= roomCapacity) {\n      if(storeData.persistentData[joinInfo.roomId].leaveUserIds.length > 0){\n        //抜けたユーザーがいる場合、入れる可能性がある。        \n        io.to(socketObj.id).emit(\"connectRetry\", {leaveUserInfo: storeData.persistentData[joinInfo.roomId].leaveUserIds});\n      }else{\n        io.to(socketObj.id).emit(\"connectError\", \"roomFull\");\n      }\n      return;\n    }\n    storeData.persistentData[joinInfo.roomId][\"users\"][socketObj.id] = {\n      dispName: commonUtil.htmlentities(joinInfo.playerName),\n      card: [],\n      rank: \"\",\n      rankNum: 0,\n      rankReason: \"\",\n      finishTime: 0,\n      point: 0,\n      firstPlace: false,\n      giveCard: [],\n      getCard: []\n    };\n    socketObj.join(joinInfo.roomId);\n    io.to(socketObj.id).emit(\"joinedRoom\", storeData.persistentData[joinInfo.roomId][\"users\"]);\n    for (let [key, value] of Object.entries(storeData.persistentData[joinInfo.roomId][\"users\"])) {\n      if (key !== socketObj.id) io.to(key).emit(\"otherMemberJoinedRoom\", commonUtil.htmlentities(joinInfo.playerName));\n    }\n    const currentPlayerNum = Object.keys(storeData.persistentData[joinInfo.roomId][\"users\"]).length;\n    if (currentPlayerNum === roomCapacity) {\n      LOGGER.info(\"There were members in the room.\");\n      gameUtil.gameInit(currentPlayerNum, storeData.persistentData[joinInfo.roomId][\"users\"], joinInfo.roomId);\n    }\n  \n};\n\nmodule.exports.reJoinRoom = (reJoinInfo, socketObj) => {\n  //TODOとりあえずあること前提で書く。でも無い場合もあるかもしれないのでその時はエラーなど対応が必要。\n  //置き換えの必要があるもの\n  //・user情報\n  //・order情報\n  //まず新しくユーザー情報を作る\n  LOGGER.debug(\"reJoinInfo:\" + JSON.stringify(reJoinInfo));\n  LOGGER.debug(\"reJoinInfoでユーザー情報とれる？:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId]));\n  let reconnectUser = {\n      dispName: reJoinInfo.playerName !== \"\" ? commonUtil.htmlentities(reJoinInfo.playerName) : storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].dispName,\n      card: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].card,\n      rank: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].rank,\n      rankNum: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].rankNum,\n      rankReason: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].rankReason,\n      finishTime: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].finishTime,\n      point: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].point,\n      firstPlace: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].firstPlace,\n      giveCard: storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId].giveCard\n  };\n  LOGGER.debug(\"接続しようとしているsocketid:\" + socketObj.id);\n  LOGGER.debug(\"前に接続していたsocketid:\" + reJoinInfo.reconnectUserId);\n  LOGGER.debug(\"今のユーザー情報:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId][\"users\"]));\n  storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id] = reconnectUser;\n  LOGGER.debug(\"追加後のユーザー情報:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId][\"users\"]));\n  delete storeData.persistentData[reJoinInfo.roomId][\"users\"][reJoinInfo.reconnectUserId];\n  \n  LOGGER.debug(\"削除後のユーザー情報:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId][\"users\"]));\n  \n  LOGGER.debug(\"置換前のorder:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId].order));\n  let orderIndex = storeData.persistentData[reJoinInfo.roomId].order.indexOf(reJoinInfo.reconnectUserId);\n  storeData.persistentData[reJoinInfo.roomId].order.splice(orderIndex, 1, socketObj.id);\n  //storeData.persistentData[reJoinInfo.roomId].order = storeData.persistentData[reJoinInfo.roomId].order.splice(orderIndex, 1, socketObj.id);\n  LOGGER.debug(\"置換後のorder:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId].order));\n  \n  //この時点でleaveメンバーから抜く\n  LOGGER.debug(\"抜く前のleaveUserIds:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId].leaveUserIds));\n  //let deleteLeaveUserPos = storeData.persistentData[reJoinInfo.roomId].leaveUserIds.indexOf(reJoinInfo.reconnectUserId);\n  let deleteLeaveUserPos = 0;\n  storeData.persistentData[reJoinInfo.roomId].leaveUserIds.some(ele => {\n    if(ele.id === reJoinInfo.reconnectUserId) return true;\n    deleteLeaveUserPos++;\n    if(deleteLeaveUserPos === storeData.persistentData[reJoinInfo.roomId].leaveUserIds.length){\n      //最後まで見つからなかったということ\n      deleteLeaveUserPos = -1;\n    }\n  });\n  if(deleteLeaveUserPos !== -1){\n    storeData.persistentData[reJoinInfo.roomId].leaveUserIds.splice(deleteLeaveUserPos, 1);\n  }else{\n    //おかしな現象なのでエラーをはいておく\n    LOGGER.error(\"なんでLeaveにいないメンバーで入ろうとしてるねん\");\n  }\n  LOGGER.debug(\"抜いたあとのleaveUserIds:\" + JSON.stringify(storeData.persistentData[reJoinInfo.roomId].leaveUserIds));\n  \n  socketObj.join(reJoinInfo.roomId);\n  \n  let giveInfo = {};\n  if(storeData.persistentData[reJoinInfo.roomId].giveCardPhase){\n    let pos = storeData.persistentData[reJoinInfo.roomId][\"order\"].indexOf(socketObj.id) + 1;\n    //カード譲渡のフェーズに戻る必要がある。\n    let playerNum = Object.keys(storeData.persistentData[reJoinInfo.roomId][\"users\"]).length;\n    if (playerNum === 3) {\n      //3人のとき\n      if(pos === 3){\n        //1位である\n        giveInfo = {type: \"higher1\",targetCard : storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card, alreadyGive: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].giveCard.length !== 0}\n      }else if(pos === 1){\n        //最下位である\n        giveInfo = {type: \"lower1\",targetCard : [storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card.slice(-1)[0]]}\n      }else{\n        //ありえないのでエラーでもはいておく\n        LOGGER.error(\"この時点で順位が出てないのはおかしい\");\n      }\n  } else {\n    //4人以上\n    if(pos === playerNum){\n        //1位である\n        giveInfo = {type: \"higher2\",targetCard: commonUtil.sortArray(storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card, true), alreadyGive: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].giveCard.length !== 0}\n      }else if(pos === playerNum - 1){\n        //2位である\n        giveInfo = {type: \"higher1\",targetCard: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card, alreadyGive: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].giveCard.length !== 0}\n      }else if(pos === 2){\n        //ビリから2番目\n        giveInfo = {type: \"lower1\", targetCard : [storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card.slice(-1)[0]]}\n      }else if(pos === 1){\n        //最下位\n        giveInfo = {type: \"lower2\", targetCard : commonUtil.sortArray([storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card.slice(-1)[0],storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card.slice(-2)[0]], true)}\n      }else{\n        //ありえないのでエラーでもはいておく\n        LOGGER.error(\"この時点で順位が出てないのはおかしい\");\n      }\n  }\n  }\n  LOGGER.debug(\"giveInfoの情報:\" + JSON.stringify(giveInfo));\n  const userDispList = [];\n  storeData.persistentData[reJoinInfo.roomId][\"order\"].forEach(key => {\n    userDispList.push(storeData.persistentData[reJoinInfo.roomId][\"users\"][key].dispName);\n  });\n  const remainingCards = [];\n  storeData.persistentData[reJoinInfo.roomId][\"order\"].forEach(key => {\n    remainingCards.push({\n      cardNum: storeData.persistentData[reJoinInfo.roomId][\"users\"][key].card.length,\n      playerName: storeData.persistentData[reJoinInfo.roomId][\"users\"][key].dispName\n    });\n  });\n  //あとはクライアントがわに送るだけ\n  //できる限り多くの情報を送らないと復活できないからね。。\n  io.to(socketObj.id).emit(\"reJoinOK\", {\n    gameNum: storeData.persistentData[reJoinInfo.roomId].gameNum,\n    card: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].card,\n    yourTurn: storeData.persistentData[reJoinInfo.roomId].currentTurnPos === storeData.persistentData[reJoinInfo.roomId].order.indexOf(socketObj.id) ? true : false,\n    playerName: storeData.persistentData[reJoinInfo.roomId][\"users\"][storeData.persistentData[reJoinInfo.roomId].order[storeData.persistentData[reJoinInfo.roomId].currentTurnPos]].dispName,\n    playerName2: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].dispName,\n    playerPoint: storeData.persistentData[reJoinInfo.roomId][\"users\"][socketObj.id].point,\n    blindCards: storeData.persistentData[reJoinInfo.roomId].blindCards,\n    orderNum: storeData.persistentData[reJoinInfo.roomId].currentTurnPos,\n    userList: userDispList,\n    roomInfo: {\n      roomDispName: storeData.persistentData[reJoinInfo.roomId].roomDispName, //部屋の表示名\n      elevenback: storeData.persistentData[reJoinInfo.roomId].elevenback, //11backフラグ\n      shibari: storeData.persistentData[reJoinInfo.roomId].shibari, //縛りフラグ\n      shibariSuites: storeData.persistentData[reJoinInfo.roomId].shibariSuites,\n      revolution: storeData.persistentData[reJoinInfo.roomId].revolution, //革命フラグ\n      fieldCards: storeData.persistentData[reJoinInfo.roomId].fieldCards, //場のカード配列\n      rankingHistory: storeData.persistentData[reJoinInfo.roomId].rankingHistory, //ランキングヒストリー\n      orders: remainingCards,\n      giveCardPhase: storeData.persistentData[reJoinInfo.roomId].giveCardPhase\n    },\n    giveInfo: giveInfo\n  });\n  for (let [key, value] of Object.entries(storeData.persistentData[reJoinInfo.roomId][\"users\"])) {\n      if (key !== socketObj.id) io.to(key).emit(\"otherMemberReJoinedOK\", {\n        playerName: reconnectUser.dispName,\n        memberOK: storeData.persistentData[reJoinInfo.roomId].leaveUserIds.length === 0\n      });\n  }\n  if(storeData.persistentData[reJoinInfo.roomId].leaveUserIds.length === 0){\n    //人数が足りているならば、緊急募集を解除してゲームを再開する\n    storeData.persistentData[reJoinInfo.roomId].status = \"inProgress\";\n  }\n};\n\nconst createDefaultRoomName = () => {\n  const now = new Date(Date.now() + ((new Date().getTimezoneOffset() + (9 * 60)) * 60 * 1000));\n  return commonUtil.formatDate(now, 'yyyy_MM_dd_HH:mm:ss.SSS');\n};\n\n\n//# sourceURL=webpack:///./src/server/roomUtil.js?");

/***/ }),

/***/ "./src/server/socketEvent.js":
/*!***********************************!*\
  !*** ./src/server/socketEvent.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// import { store, io } from './index';\n// const log4js = require(\"log4js\");\n// const logger = log4js.getLogger();\n// const app = require(\"express\")();\n// const http = require(\"http\").Server(app);\n// const io = require(\"socket.io\")(http);\nconst storeData = __webpack_require__(/*! ./storeData.js */ \"./src/server/storeData.js\");\nconst commonRequire = __webpack_require__(/*! ./commonRequire.js */ \"./src/server/commonRequire.js\");\nconst commonUtil = __webpack_require__(/*! ./commonUtil.js */ \"./src/server/commonUtil.js\");\nconst roomUtil = __webpack_require__(/*! ./roomUtil.js */ \"./src/server/roomUtil.js\");\nconst loggerUtil = __webpack_require__(/*! ./loggerUtil.js */ \"./src/server/loggerUtil.js\");\nconst LOGGER = loggerUtil.logger;\nconst notifyUtil = __webpack_require__(/*! ./notifyUtil.js */ \"./src/server/notifyUtil.js\");\nconst io = commonRequire.io;\nmodule.exports.load_common_event = (socket)=> {\n  socket.on(\"disconnect\", () => {\n    const roomIds = Object.keys(storeData.persistentData);\n    for (const roomId of roomIds) {\n      if (~Object.keys(storeData.persistentData[roomId][\"users\"]).indexOf(socket.id)) {\n        console.log(\n          storeData.persistentData[roomId][\"users\"][socket.id].dispName +\n            \"が\" +\n            storeData.persistentData[roomId].roomDispName +\n            \"から退出\"\n        );\n        console.log(\"storeの状態\" + JSON.stringify(storeData.persistentData));\n        //delete storeData.persistentData[roomId][\"users\"][socket.id];\n        socket.leave(roomId);\n        if (storeData.persistentData[roomId].startedGame) {\n          LOGGER.debug(\"leaveUserIdsの状態\" + JSON.stringify(storeData.persistentData[roomId].leaveUserIds));\n          storeData.persistentData[roomId].status = \"urgentRecruiting\";\n          storeData.persistentData[roomId].leaveUserIds.push({id:socket.id, dispName: storeData.persistentData[roomId][\"users\"][socket.id].dispName});\n          console.log(\"送る\" + JSON.stringify(roomId) + \"と\" + storeData.persistentData[roomId].roomId);\n          io.to(storeData.persistentData[roomId].roomId).emit(\"releaseRoom\", {\n            reason: \"goOutRoom\"\n          });\n        }else{\n          //ゲーム始まっていないなら抜けるだけ\n          //TOODなんか送ったほうがいいのか？\n        }\n        //部屋の状態もおかしくなるので削除する\n        //delete storeData.persistentData[roomId];\n      }\n    }\n});\n};\n\nmodule.exports.load_room_event = (socket)=> {\n  socket.on(\"requestRoomCreate\", roomInfo => {\n    roomUtil.createRoom(roomInfo);\n  });\n  socket.on(\"join\", joinInfo => {\n    roomUtil.joinRoom(joinInfo, socket);\n  });\n  socket.on(\"reJoin\", reJoinInfo => {\n    roomUtil.reJoinRoom(reJoinInfo, socket);\n  });\n};\n\nmodule.exports.load_game_event = (socket)=> {\n  socket.on(\"pass\", function(msg) {\n    const orderList = storeData.persistentData[msg.id][\"order\"];\n    const users = storeData.persistentData[msg.id][\"users\"];\n    if(storeData.persistentData[msg.id].fieldCards.length === 0){\n      //フィールドにカードが出ていない場合はパスできない。\n      commonRequire.io.to(socket.id).emit(\"validateError\", {\n        error: 1,\n        reason: \"fieldNothing\"\n      });\n      return;\n    }\n    storeData.persistentData[msg.id].passCount = storeData.persistentData[msg.id].passCount + 1;\n    //const count = store[msg.id].capacity;\n    LOGGER.debug(\n      \"今のpassCount:\" +\n        storeData.persistentData[msg.id].passCount +\n        \" 今のorderList長さ\" +\n        orderList.length\n    );\n    if (storeData.persistentData[msg.id].passCount >= orderList.length - 1) {\n      //パスで一周した場合流す\n      LOGGER.debug(\"流します\");\n      storeData.fieldClear(msg.id);\n      commonRequire.io.to(storeData.persistentData[msg.id].roomId).emit(\"changeStatus\", { type: \"cutPass\" });\n    }\n\n    let currentTurn = orderList.indexOf(socket.id);\n\n    notifyUtil.notifyChangeTurn(currentTurn, msg.id);\n  });\n};\n\n\n//# sourceURL=webpack:///./src/server/socketEvent.js?");

/***/ }),

/***/ "./src/server/storeData.js":
/*!*********************************!*\
  !*** ./src/server/storeData.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const commonUtil = __webpack_require__(/*! ./commonUtil.js */ \"./src/server/commonUtil.js\");\n\nmodule.exports.persistentData = {};\n\nmodule.exports.createRankTable = (count) => {\n  if (count == 2) {\n    return [{ rankId: \"hugou\", point: 1 }, { rankId: \"hinmin\", point: 0 }];\n  } else if (count == 3) {\n    return [\n      { rankId: \"hugou\", point: 1 },\n      { rankId: \"heimin\", point: 0 },\n      { rankId: \"hinmin\", point: -1 }\n    ];\n  } else if (count == 4) {\n    return [\n      { rankId: \"daihugou\", point: 2 },\n      { rankId: \"hugou\", point: 1 },\n      { rankId: \"hinmin\", point: 0 },\n      { rankId: \"daihinmin\", point: -1 }\n    ];\n  } else {\n    let rankTable = [\n      { rankId: \"daihugou\", point: 2 },\n      { rankId: \"hugou\", point: 1 }\n    ];\n    for (let i = 0; i < count - 4; i++) {\n      rankTable.push({ rankId: \"heimin\", point: 0 });\n    }\n    rankTable.push({ rankId: \"heimin\", point: -1 });\n    rankTable.push({ rankId: \"hinmin\", point: -2 });\n    return rankTable;\n  }\n}\n\nmodule.exports.fieldClear = (roomId) => {\n  module.exports.persistentData[roomId][\"fieldCards\"] = [];\n  module.exports.persistentData[roomId].passCount = 0;\n  module.exports.persistentData[roomId].elevenback = false;\n  module.exports.persistentData[roomId].stair = false;\n  module.exports.persistentData[roomId].shibari = false;\n  module.exports.persistentData[roomId].shibariSuites = [];\n}\n\nmodule.exports.sortCard = (roomId, userId, isASC = true) => {\n  module.exports.persistentData[roomId]['users'][userId].card = commonUtil.sortArray(module.exports.persistentData[roomId]['users'][userId].card, isASC);\n}\n\n//# sourceURL=webpack:///./src/server/storeData.js?");

/***/ }),

/***/ "./src/server/validateUtil.js":
/*!************************************!*\
  !*** ./src/server/validateUtil.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst loggerUtil = __webpack_require__(/*! ./loggerUtil.js */ \"./src/server/loggerUtil.js\");\nconst LOGGER = loggerUtil.logger;\n\n/*\nカードの役を確認する\n*/\nmodule.exports.checkValidateHand = (sc) => {\n  //1枚だし\n  //複数枚だし\n  //階段(3枚以上、順番、同スート)\n  let result = {\n    error: 0,\n    type: \"\"\n  };\n  if (sc.length === 1) {\n    //1枚だしは特に問題なし\n    LOGGER.debug(\"大富豪の役：1枚だし\");\n    result.type = \"unit\";\n  } else if (isAllSameNumber(sc)) {\n    //複数枚だしで数字がそろっていること\n    LOGGER.debug(\"大富豪の役：複数枚だし\");\n    result.type = \"multiple\";\n  } else if (isStairsCard(sc)) {\n    //階段\n    LOGGER.debug(\"大富豪の役：階段\");\n    result.type = \"stair\";\n  } else {\n    result.error = 1;\n  }\n  return result;\n}\n\n/*\nすべての数字が同じかどうか判定。\n(JOKERも対応)\n*/\nconst isAllSameNumber = (sc) => {\n  let base = sc[0].number;\n  for (let i = 1; i < sc.length; i++) {\n    if (~sc[i].type.indexOf(\"joker\")) {\n      continue;\n    }\n    if (base !== sc[i].number) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n階段かどうか判定\n*/\nconst isStairsCard = (sc) => {\n  //Jokerの数を確認\n  let jokerCount = sc.filter(item => ~item.type.indexOf(\"joker\")).length;\n  if (sc.length < 3) {\n    //3枚以上でなければ階段ではない\n    return false;\n  }\n  //Note 数字1枚、ジョーカー2枚は複数出しになるので意識しなくてよい。\n  let suit = false;\n  let stairNum = false;\n  for (let i = 0; i < sc.length; i++) {\n    //比較対象がない場合は抜ける。\n    if (i + 1 === sc.length) {\n      break;\n    }\n    //比較対象がJokerの場合は終わり\n    if (~sc[i + 1].type.indexOf(\"joker\")) {\n      break;\n    }\n    //スートチェック\n    if (sc[i + 1].type === sc[i].type) {\n      suit = true;\n    } else {\n      return false; //1回でもマークが違ったら階段ではない\n    }\n    //階段チェック\n    //Note 差が0のときはスートチェックで引っかかるので相手しない\n    const diff = sc[i + 1].number - sc[i].number;\n    if (diff === 1) {\n      //差が1なら階段と判断\n      stairNum = true;\n    } else {\n      if (jokerCount > 0) {\n        //Jokerで救えるか確認する\n        if (diff - 1 <= jokerCount) {\n          stairNum = true;\n          jokerCount = jokerCount - (diff - 1);\n        } else {\n          //Jokerでも救うことができない\n          return false;\n        }\n      } else {\n        //Jokerがなく、差が1より大きいと階段ではない\n        return false;\n      }\n    }\n  }\n  return suit && stairNum;\n}\n\n//autoパスできるか否か\nconst isAutoPass = (roomId) => {\n  \n}\n\n//# sourceURL=webpack:///./src/server/validateUtil.js?");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"express\");\n\n//# sourceURL=webpack:///external_%22express%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "log4js":
/*!*************************!*\
  !*** external "log4js" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"log4js\");\n\n//# sourceURL=webpack:///external_%22log4js%22?");

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"socket.io\");\n\n//# sourceURL=webpack:///external_%22socket.io%22?");

/***/ })

/******/ });